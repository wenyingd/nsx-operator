package subnetbinding

import (
	"context"
	"sync"

	"github.com/vmware/vsphere-automation-sdk-go/services/nsxt/model"
	"k8s.io/apimachinery/pkg/util/sets"

	"github.com/vmware-tanzu/nsx-operator/pkg/apis/vpc/v1alpha1"
	"github.com/vmware-tanzu/nsx-operator/pkg/logger"
	servicecommon "github.com/vmware-tanzu/nsx-operator/pkg/nsx/services/common"
	nsxutil "github.com/vmware-tanzu/nsx-operator/pkg/nsx/util"
)

var (
	log                                    = &logger.Log
	ResourceTypeSubnetConnectionBindingMap = servicecommon.ResourceTypeSubnetConnectionBIndingMap
	enforceRevisionCheckParam              = false
)

type BindingService struct {
	servicecommon.Service
	BindingStore *BindingStore
}

// InitializeService initialize SubnetConnectionBindingMap service.
func InitializeService(service servicecommon.Service) (*BindingService, error) {
	wg := sync.WaitGroup{}
	fatalErrors := make(chan error, 1)
	defer close(fatalErrors)

	bindingService := &BindingService{
		Service:      service,
		BindingStore: SetupStore(),
	}

	wg.Add(1)
	go service.InitializeResourceStore(&wg, fatalErrors, ResourceTypeSubnetConnectionBindingMap, nil, bindingService.BindingStore)
	wg.Wait()

	if len(fatalErrors) > 0 {
		err := <-fatalErrors
		return bindingService, err
	}

	return bindingService, nil
}

// CreateOrUpdateSubnetConnectionBindingMap creates or updates the SubnetConnectionBindingMaps with the given
// subnetBinding CR and attaching to the parentSubnets.
func (s *BindingService) CreateOrUpdateSubnetConnectionBindingMap(
	subnetBinding *v1alpha1.SubnetConnectionBindingMap,
	childSubnet *model.VpcSubnet,
	parentSubnets []*model.VpcSubnet) error {
	desiredBMmap := bindingMapsToMap(s.buildSubnetBindings(subnetBinding, parentSubnets))
	existingBMmap := bindingMapsToMap(s.BindingStore.getBindingsByBindingMapCRUID(string(subnetBinding.UID)))
	updatedBindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	for k, v := range desiredBMmap {
		existBindingMap, found := existingBMmap[k]
		if !found {
			updatedBindingMaps = append(updatedBindingMaps, v)
			continue
		}
		changed := servicecommon.CompareResource(SubnetConnectionBindingMapToComparable(existBindingMap), SubnetConnectionBindingMapToComparable(v))
		if changed {
			updatedBindingMaps = append(updatedBindingMaps, v)
		}
	}
	// Mark the SubnetConnectionBindingMap as for-delete if it exists in the store but does not exist in the desired resources.
	for k, v := range existingBMmap {
		_, found := desiredBMmap[k]
		if !found {
			toDelBindingMap := *v
			toDelBindingMap.MarkedForDelete = Bool(true)
			updatedBindingMaps = append(updatedBindingMaps, &toDelBindingMap)
		}
	}

	finalBindingMaps, err := s.Apply(*childSubnet.Path, updatedBindingMaps)
	if err != nil {
		return err
	}

	// apply the latest NSX SubnetConnectionBindingMaps into BindingStore.
	for _, bm := range finalBindingMaps {
		s.BindingStore.Apply(bm)
	}
	return nil
}

// DeleteSubnetConnectionBindingMapsByCRName deletes all the SubnetConnectionBindingMaps generated by the given subnetBinding
// CR's UID.
func (s *BindingService) DeleteSubnetConnectionBindingMapsByCRName(bindingName string, bindingNamespace string) error {
	bindingMaps := s.BindingStore.getBindingsByBindingMapCRName(bindingName, bindingNamespace)
	return s.deleteSubnetConnectionBindingMaps(bindingMaps)
}

// DeleteSubnetConnectionBindingMapsByCRUID deletes all the SubnetConnectionBindingMaps generated by the given subnetBinding
// CR's UID.
func (s *BindingService) DeleteSubnetConnectionBindingMapsByCRUID(bindingUID string) error {
	bindingMaps := s.BindingStore.getBindingsByBindingMapCRUID(bindingUID)
	return s.deleteSubnetConnectionBindingMaps(bindingMaps)
}

// DeleteSubnetConnectionBindingMapsByParentSubnets deletes all the SubnetConnectionBindingMaps bound to the
// given parentSubnets.
func (s *BindingService) DeleteSubnetConnectionBindingMapsByParentSubnets(parentSubnets []*model.VpcSubnet) error {
	bindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	for _, subnet := range parentSubnets {
		if subnet.Path == nil {
			log.Info("Parent VpcSubnet had no configured Path, ignoring", "subnet", *subnet.Id)
			continue
		}
		subnetPath := *subnet.Path
		bindingMaps = append(bindingMaps, s.BindingStore.getBindingsByParentSubnet(subnetPath)...)
	}
	return s.deleteSubnetConnectionBindingMaps(bindingMaps)
}

// GetSubnetConnectionBindingMapsBySubnet returns all the SubnetConnectionBindingMaps referred to the given subnet.
// The function returns the SubnetConnectionBindingMaps associated with the subnet if exists, otherwise it returns
// the SubnetConnectionBindingMaps connected to the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsBySubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	bindingMapsByChild := s.GetSubnetConnectionBindingMapsByChildSubnet(subnet)
	if len(bindingMapsByChild) > 0 {
		return bindingMapsByChild
	}
	return s.GetSubnetConnectionBindingMapsByParentSubnet(subnet)
}

// GetSubnetConnectionBindingMapsByChildSubnet returns the SubnetConnectionBindingMaps associated with the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsByChildSubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	return s.BindingStore.getBindingsByChildSubnet(*subnet.Path)
}

// GetSubnetConnectionBindingMapsByParentSubnet returns the SubnetConnectionBindingMaps connected to the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsByParentSubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	return s.BindingStore.getBindingsByParentSubnet(*subnet.Path)
}

func (s *BindingService) GetSubnetConnectionBindingMapCRsBySubnet(subnet *model.VpcSubnet) []*v1alpha1.SubnetConnectionBindingMap {
	nsxBindingMaps := s.GetSubnetConnectionBindingMapsBySubnet(subnet)
	if len(nsxBindingMaps) == 0 {
		return nil
	}

	subnetConnectionBindingMaps := sets.New[*v1alpha1.SubnetConnectionBindingMap]()
	for _, bm := range nsxBindingMaps {
		obj, err := buildSubnetConnectionBindingMapCR(bm)
		if err != nil {
			log.Error(err, "Unable to get SubnetConnectionBindingMap CR from NSX resource", "bindingMap", *bm.Id)
			continue
		}
		subnetConnectionBindingMaps.Insert(obj)
	}
	return subnetConnectionBindingMaps.UnsortedList()
}

func (s *BindingService) ListSubnetConnectionBindingMapCRUIDsInStore() sets.Set[string] {
	crUIDs := sets.New[string]()
	for _, obj := range s.BindingStore.List() {
		bm, _ := obj.(*model.SubnetConnectionBindingMap)
		res, err := buildSubnetConnectionBindingMapCR(bm)
		if err != nil {
			log.Error(err, "Unable to get SubnetConnectionBindingMap CR from NSX resource", "bindingMap", *bm.Id)
			continue
		}
		crUIDs.Insert(string(res.UID))
	}
	return crUIDs
}

// Apply sync bindingMaps on NSX. If mergeNSXData is true, it will read the latest SubnetConnectionBindingMaps data
// required in the given bindingMaps from NSX.
func (s *BindingService) Apply(subnetPath string, bindingMaps []*model.SubnetConnectionBindingMap) ([]*model.SubnetConnectionBindingMap, error) {
	vpcInfo, err := servicecommon.ParseVPCResourcePath(subnetPath)
	if err != nil {
		return nil, err
	}
	subnetID := vpcInfo.ID

	orgRoot, err := buildOrgRootBySubnetConnectionBindingMaps(bindingMaps, nil, subnetPath)
	if err != nil {
		return nil, err
	}

	if err = s.NSXClient.OrgRootClient.Patch(*orgRoot, &enforceRevisionCheckParam); err != nil {
		log.Error(err, "Failed to patch SubnetConnectionBindingMaps on NSX", "orgID", vpcInfo.OrgID, "projectID", vpcInfo.ProjectID, "vpcID", vpcInfo.VPCID, "subnetID", subnetID, "subnetConnectionBindingMaps", bindingMaps)
		err = nsxutil.TransNSXApiError(err)
		return nil, err
	}

	// Get SubnetConnectionBindingMaps from NSX after patch operation as NSX renders several fields like `path`/`parent_path`.
	subnetBindingListResult, err := s.NSXClient.SubnetConnectionBindingMapsClient.List(vpcInfo.OrgID, vpcInfo.ProjectID, vpcInfo.VPCID, subnetID, nil, nil, nil, nil, nil, nil)
	if err != nil {
		log.Error(err, "Failed to list SubnetConnectionBindingMaps from NSX under subnet", "orgID", vpcInfo.OrgID, "projectID", vpcInfo.ProjectID, "vpcID", vpcInfo.VPCID, "subnetID", subnetID, "subnetConnectionBindingMaps", bindingMaps)
		err = nsxutil.TransNSXApiError(err)
		return nil, err
	}

	nsxBindingMaps := make(map[string]model.SubnetConnectionBindingMap)
	for _, bm := range subnetBindingListResult.Results {
		nsxBindingMaps[*bm.Id] = bm
	}

	finalBindingMaps := make([]*model.SubnetConnectionBindingMap, len(bindingMaps))
	for i := range bindingMaps {
		bm := bindingMaps[i]
		if bm.MarkedForDelete != nil && *bm.MarkedForDelete {
			finalBindingMaps[i] = bm
		} else {
			nsxBindingMap := nsxBindingMaps[*bm.Id]
			finalBindingMaps[i] = &nsxBindingMap
		}
	}

	return finalBindingMaps, nil
}

func (s *BindingService) deleteSubnetConnectionBindingMaps(bindingMaps []*model.SubnetConnectionBindingMap) error {
	// Add this check is for security purpose. The caller has similar pre-check and returned if no items exist in the bindingMaps.
	if len(bindingMaps) == 0 {
		log.Info("No existing SubnetConnectionBindingMaps found in the store")
		return nil
	}
	err := s.hDeleteSubnetConnectionBindingMap(bindingMaps)
	if err != nil {
		return err
	}

	// Remove SubnetConnectionBindingMap from local store.
	for _, bm := range bindingMaps {
		s.BindingStore.Apply(bm)
	}
	return nil
}

func (s *BindingService) DeleteMultiSubnetConnectionBindingMapsByCRs(bindingCRs sets.Set[string]) error {
	if bindingCRs.Len() == 0 {
		return nil
	}
	finalBindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	for _, crID := range bindingCRs.UnsortedList() {
		bms := s.BindingStore.getBindingsByBindingMapCRUID(crID)
		finalBindingMaps = append(finalBindingMaps, bms...)
	}
	return s.deleteSubnetConnectionBindingMaps(finalBindingMaps)
}

func (s *BindingService) hDeleteSubnetConnectionBindingMap(bindingMaps []*model.SubnetConnectionBindingMap) error {
	markForDelete := true
	orgRoot, err := buildOrgRootBySubnetConnectionBindingMaps(bindingMaps, &markForDelete, "")
	if err != nil {
		return err
	}

	if err = s.NSXClient.OrgRootClient.Patch(*orgRoot, &enforceRevisionCheckParam); err != nil {
		log.Error(err, "Failed to delete multiple SubnetConnectionBindingMaps on NSX with HAPI")
		err = nsxutil.TransNSXApiError(err)
		return err
	}
	return nil
}

func (s *BindingService) GetCRNameBySubnetConnectionBindingMap(bindingMap *model.SubnetConnectionBindingMap) string {
	if bindingMap == nil {
		return ""
	}
	for _, tag := range bindingMap.Tags {
		if *tag.Scope == servicecommon.TagScopeSubnetBindingCRName {
			return *tag.Tag
		}
	}
	return ""
}

func (s *BindingService) Cleanup(ctx context.Context) error {
	allNSXBindings := s.BindingStore.List()
	log.Info("Cleaning up SubnetConnectionBindingMaps", "Count", len(allNSXBindings))
	finalBindingMaps := make([]*model.SubnetConnectionBindingMap, len(allNSXBindings))
	for i, obj := range allNSXBindings {
		binding, _ := obj.(*model.SubnetConnectionBindingMap)
		finalBindingMaps[i] = binding
	}

	return s.deleteSubnetConnectionBindingMaps(finalBindingMaps)
}

func bindingMapsToMap(bindingMaps []*model.SubnetConnectionBindingMap) map[string]*model.SubnetConnectionBindingMap {
	bmMap := make(map[string]*model.SubnetConnectionBindingMap)
	for _, bm := range bindingMaps {
		bmMap[*bm.Id] = bm
	}
	return bmMap
}
